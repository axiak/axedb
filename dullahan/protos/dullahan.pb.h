// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dullahan.proto

#ifndef PROTOBUF_dullahan_2eproto__INCLUDED
#define PROTOBUF_dullahan_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace dullahan {
namespace models {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dullahan_2eproto();
void protobuf_AssignDesc_dullahan_2eproto();
void protobuf_ShutdownFile_dullahan_2eproto();

class Record;
class Record_KeyValue;
class TableSchema;
class TableSchema_Column;
class TabletMetadata;
class Query;
class Query_Predicate;

enum TableSchema_Column_ColumnType {
  TableSchema_Column_ColumnType_BYTES = 1,
  TableSchema_Column_ColumnType_STRING = 2,
  TableSchema_Column_ColumnType_BOOL = 3,
  TableSchema_Column_ColumnType_SMALLINT = 4,
  TableSchema_Column_ColumnType_INTEGER = 5,
  TableSchema_Column_ColumnType_BIGINT = 6,
  TableSchema_Column_ColumnType_FLOAT = 7,
  TableSchema_Column_ColumnType_DOUBLE = 8
};
bool TableSchema_Column_ColumnType_IsValid(int value);
const TableSchema_Column_ColumnType TableSchema_Column_ColumnType_ColumnType_MIN = TableSchema_Column_ColumnType_BYTES;
const TableSchema_Column_ColumnType TableSchema_Column_ColumnType_ColumnType_MAX = TableSchema_Column_ColumnType_DOUBLE;
const int TableSchema_Column_ColumnType_ColumnType_ARRAYSIZE = TableSchema_Column_ColumnType_ColumnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TableSchema_Column_ColumnType_descriptor();
inline const ::std::string& TableSchema_Column_ColumnType_Name(TableSchema_Column_ColumnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TableSchema_Column_ColumnType_descriptor(), value);
}
inline bool TableSchema_Column_ColumnType_Parse(
    const ::std::string& name, TableSchema_Column_ColumnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TableSchema_Column_ColumnType>(
    TableSchema_Column_ColumnType_descriptor(), name, value);
}
enum TableSchema_Column_IndexType {
  TableSchema_Column_IndexType_NONE = 0,
  TableSchema_Column_IndexType_BITMAP = 1
};
bool TableSchema_Column_IndexType_IsValid(int value);
const TableSchema_Column_IndexType TableSchema_Column_IndexType_IndexType_MIN = TableSchema_Column_IndexType_NONE;
const TableSchema_Column_IndexType TableSchema_Column_IndexType_IndexType_MAX = TableSchema_Column_IndexType_BITMAP;
const int TableSchema_Column_IndexType_IndexType_ARRAYSIZE = TableSchema_Column_IndexType_IndexType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TableSchema_Column_IndexType_descriptor();
inline const ::std::string& TableSchema_Column_IndexType_Name(TableSchema_Column_IndexType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TableSchema_Column_IndexType_descriptor(), value);
}
inline bool TableSchema_Column_IndexType_Parse(
    const ::std::string& name, TableSchema_Column_IndexType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TableSchema_Column_IndexType>(
    TableSchema_Column_IndexType_descriptor(), name, value);
}
enum TabletMetadata_TabletVersion {
  TabletMetadata_TabletVersion_ONE = 1
};
bool TabletMetadata_TabletVersion_IsValid(int value);
const TabletMetadata_TabletVersion TabletMetadata_TabletVersion_TabletVersion_MIN = TabletMetadata_TabletVersion_ONE;
const TabletMetadata_TabletVersion TabletMetadata_TabletVersion_TabletVersion_MAX = TabletMetadata_TabletVersion_ONE;
const int TabletMetadata_TabletVersion_TabletVersion_ARRAYSIZE = TabletMetadata_TabletVersion_TabletVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* TabletMetadata_TabletVersion_descriptor();
inline const ::std::string& TabletMetadata_TabletVersion_Name(TabletMetadata_TabletVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    TabletMetadata_TabletVersion_descriptor(), value);
}
inline bool TabletMetadata_TabletVersion_Parse(
    const ::std::string& name, TabletMetadata_TabletVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TabletMetadata_TabletVersion>(
    TabletMetadata_TabletVersion_descriptor(), name, value);
}
enum TabletMetadata_Endianness {
  TabletMetadata_Endianness_BIG = 0,
  TabletMetadata_Endianness_LITTLE = 1
};
bool TabletMetadata_Endianness_IsValid(int value);
const TabletMetadata_Endianness TabletMetadata_Endianness_Endianness_MIN = TabletMetadata_Endianness_BIG;
const TabletMetadata_Endianness TabletMetadata_Endianness_Endianness_MAX = TabletMetadata_Endianness_LITTLE;
const int TabletMetadata_Endianness_Endianness_ARRAYSIZE = TabletMetadata_Endianness_Endianness_MAX + 1;

const ::google::protobuf::EnumDescriptor* TabletMetadata_Endianness_descriptor();
inline const ::std::string& TabletMetadata_Endianness_Name(TabletMetadata_Endianness value) {
  return ::google::protobuf::internal::NameOfEnum(
    TabletMetadata_Endianness_descriptor(), value);
}
inline bool TabletMetadata_Endianness_Parse(
    const ::std::string& name, TabletMetadata_Endianness* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TabletMetadata_Endianness>(
    TabletMetadata_Endianness_descriptor(), name, value);
}
enum Query_Predicate_PredicateType {
  Query_Predicate_PredicateType_NODE = 1,
  Query_Predicate_PredicateType_AND = 2,
  Query_Predicate_PredicateType_OR = 3
};
bool Query_Predicate_PredicateType_IsValid(int value);
const Query_Predicate_PredicateType Query_Predicate_PredicateType_PredicateType_MIN = Query_Predicate_PredicateType_NODE;
const Query_Predicate_PredicateType Query_Predicate_PredicateType_PredicateType_MAX = Query_Predicate_PredicateType_OR;
const int Query_Predicate_PredicateType_PredicateType_ARRAYSIZE = Query_Predicate_PredicateType_PredicateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Query_Predicate_PredicateType_descriptor();
inline const ::std::string& Query_Predicate_PredicateType_Name(Query_Predicate_PredicateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Query_Predicate_PredicateType_descriptor(), value);
}
inline bool Query_Predicate_PredicateType_Parse(
    const ::std::string& name, Query_Predicate_PredicateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Query_Predicate_PredicateType>(
    Query_Predicate_PredicateType_descriptor(), name, value);
}
enum Query_Predicate_Operator {
  Query_Predicate_Operator_EQUAL = 1,
  Query_Predicate_Operator_NOT_EQUAL = 2,
  Query_Predicate_Operator_GREATER = 3,
  Query_Predicate_Operator_GREATER_OR_EQUAL = 4,
  Query_Predicate_Operator_LESS = 5,
  Query_Predicate_Operator_LESS_OR_EQUAL = 6,
  Query_Predicate_Operator_IN = 7,
  Query_Predicate_Operator_NOT_IN = 8,
  Query_Predicate_Operator_BETWEEN = 9,
  Query_Predicate_Operator_NOT_BETWEEN = 10,
  Query_Predicate_Operator_LIKE = 11,
  Query_Predicate_Operator_NOT_LIKE = 12,
  Query_Predicate_Operator_IS_NULL = 13,
  Query_Predicate_Operator_IS_NOT_NULL = 14
};
bool Query_Predicate_Operator_IsValid(int value);
const Query_Predicate_Operator Query_Predicate_Operator_Operator_MIN = Query_Predicate_Operator_EQUAL;
const Query_Predicate_Operator Query_Predicate_Operator_Operator_MAX = Query_Predicate_Operator_IS_NOT_NULL;
const int Query_Predicate_Operator_Operator_ARRAYSIZE = Query_Predicate_Operator_Operator_MAX + 1;

const ::google::protobuf::EnumDescriptor* Query_Predicate_Operator_descriptor();
inline const ::std::string& Query_Predicate_Operator_Name(Query_Predicate_Operator value) {
  return ::google::protobuf::internal::NameOfEnum(
    Query_Predicate_Operator_descriptor(), value);
}
inline bool Query_Predicate_Operator_Parse(
    const ::std::string& name, Query_Predicate_Operator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Query_Predicate_Operator>(
    Query_Predicate_Operator_descriptor(), name, value);
}
// ===================================================================

class Record_KeyValue : public ::google::protobuf::Message {
 public:
  Record_KeyValue();
  virtual ~Record_KeyValue();

  Record_KeyValue(const Record_KeyValue& from);

  inline Record_KeyValue& operator=(const Record_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_KeyValue& default_instance();

  void Swap(Record_KeyValue* other);

  // implements Message ----------------------------------------------

  Record_KeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_KeyValue& from);
  void MergeFrom(const Record_KeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 column = 1;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline ::google::protobuf::uint32 column() const;
  inline void set_column(::google::protobuf::uint32 value);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:dullahan.models.Record.KeyValue)
 private:
  inline void set_has_column();
  inline void clear_has_column();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  ::google::protobuf::uint32 column_;
  friend void  protobuf_AddDesc_dullahan_2eproto();
  friend void protobuf_AssignDesc_dullahan_2eproto();
  friend void protobuf_ShutdownFile_dullahan_2eproto();

  void InitAsDefaultInstance();
  static Record_KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class Record : public ::google::protobuf::Message {
 public:
  Record();
  virtual ~Record();

  Record(const Record& from);

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record& default_instance();

  void Swap(Record* other);

  // implements Message ----------------------------------------------

  Record* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Record_KeyValue KeyValue;

  // accessors -------------------------------------------------------

  // optional fixed64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional bytes id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated .dullahan.models.Record.KeyValue values = 3;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 3;
  inline const ::dullahan::models::Record_KeyValue& values(int index) const;
  inline ::dullahan::models::Record_KeyValue* mutable_values(int index);
  inline ::dullahan::models::Record_KeyValue* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::dullahan::models::Record_KeyValue >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::dullahan::models::Record_KeyValue >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:dullahan.models.Record)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::dullahan::models::Record_KeyValue > values_;
  friend void  protobuf_AddDesc_dullahan_2eproto();
  friend void protobuf_AssignDesc_dullahan_2eproto();
  friend void protobuf_ShutdownFile_dullahan_2eproto();

  void InitAsDefaultInstance();
  static Record* default_instance_;
};
// -------------------------------------------------------------------

class TableSchema_Column : public ::google::protobuf::Message {
 public:
  TableSchema_Column();
  virtual ~TableSchema_Column();

  TableSchema_Column(const TableSchema_Column& from);

  inline TableSchema_Column& operator=(const TableSchema_Column& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableSchema_Column& default_instance();

  void Swap(TableSchema_Column* other);

  // implements Message ----------------------------------------------

  TableSchema_Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableSchema_Column& from);
  void MergeFrom(const TableSchema_Column& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TableSchema_Column_ColumnType ColumnType;
  static const ColumnType BYTES = TableSchema_Column_ColumnType_BYTES;
  static const ColumnType STRING = TableSchema_Column_ColumnType_STRING;
  static const ColumnType BOOL = TableSchema_Column_ColumnType_BOOL;
  static const ColumnType SMALLINT = TableSchema_Column_ColumnType_SMALLINT;
  static const ColumnType INTEGER = TableSchema_Column_ColumnType_INTEGER;
  static const ColumnType BIGINT = TableSchema_Column_ColumnType_BIGINT;
  static const ColumnType FLOAT = TableSchema_Column_ColumnType_FLOAT;
  static const ColumnType DOUBLE = TableSchema_Column_ColumnType_DOUBLE;
  static inline bool ColumnType_IsValid(int value) {
    return TableSchema_Column_ColumnType_IsValid(value);
  }
  static const ColumnType ColumnType_MIN =
    TableSchema_Column_ColumnType_ColumnType_MIN;
  static const ColumnType ColumnType_MAX =
    TableSchema_Column_ColumnType_ColumnType_MAX;
  static const int ColumnType_ARRAYSIZE =
    TableSchema_Column_ColumnType_ColumnType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ColumnType_descriptor() {
    return TableSchema_Column_ColumnType_descriptor();
  }
  static inline const ::std::string& ColumnType_Name(ColumnType value) {
    return TableSchema_Column_ColumnType_Name(value);
  }
  static inline bool ColumnType_Parse(const ::std::string& name,
      ColumnType* value) {
    return TableSchema_Column_ColumnType_Parse(name, value);
  }

  typedef TableSchema_Column_IndexType IndexType;
  static const IndexType NONE = TableSchema_Column_IndexType_NONE;
  static const IndexType BITMAP = TableSchema_Column_IndexType_BITMAP;
  static inline bool IndexType_IsValid(int value) {
    return TableSchema_Column_IndexType_IsValid(value);
  }
  static const IndexType IndexType_MIN =
    TableSchema_Column_IndexType_IndexType_MIN;
  static const IndexType IndexType_MAX =
    TableSchema_Column_IndexType_IndexType_MAX;
  static const int IndexType_ARRAYSIZE =
    TableSchema_Column_IndexType_IndexType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IndexType_descriptor() {
    return TableSchema_Column_IndexType_descriptor();
  }
  static inline const ::std::string& IndexType_Name(IndexType value) {
    return TableSchema_Column_IndexType_Name(value);
  }
  static inline bool IndexType_Parse(const ::std::string& name,
      IndexType* value) {
    return TableSchema_Column_IndexType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .dullahan.models.TableSchema.Column.ColumnType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::dullahan::models::TableSchema_Column_ColumnType type() const;
  inline void set_type(::dullahan::models::TableSchema_Column_ColumnType value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool enabled = 3 [default = true];
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 3;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional .dullahan.models.TableSchema.Column.IndexType index_type = 4 [default = BITMAP];
  inline bool has_index_type() const;
  inline void clear_index_type();
  static const int kIndexTypeFieldNumber = 4;
  inline ::dullahan::models::TableSchema_Column_IndexType index_type() const;
  inline void set_index_type(::dullahan::models::TableSchema_Column_IndexType value);

  // @@protoc_insertion_point(class_scope:dullahan.models.TableSchema.Column)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_index_type();
  inline void clear_has_index_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int type_;
  bool enabled_;
  int index_type_;
  friend void  protobuf_AddDesc_dullahan_2eproto();
  friend void protobuf_AssignDesc_dullahan_2eproto();
  friend void protobuf_ShutdownFile_dullahan_2eproto();

  void InitAsDefaultInstance();
  static TableSchema_Column* default_instance_;
};
// -------------------------------------------------------------------

class TableSchema : public ::google::protobuf::Message {
 public:
  TableSchema();
  virtual ~TableSchema();

  TableSchema(const TableSchema& from);

  inline TableSchema& operator=(const TableSchema& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableSchema& default_instance();

  void Swap(TableSchema* other);

  // implements Message ----------------------------------------------

  TableSchema* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableSchema& from);
  void MergeFrom(const TableSchema& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TableSchema_Column Column;

  // accessors -------------------------------------------------------

  // optional string table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // repeated .dullahan.models.TableSchema.Column columns = 2;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 2;
  inline const ::dullahan::models::TableSchema_Column& columns(int index) const;
  inline ::dullahan::models::TableSchema_Column* mutable_columns(int index);
  inline ::dullahan::models::TableSchema_Column* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::dullahan::models::TableSchema_Column >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::dullahan::models::TableSchema_Column >*
      mutable_columns();

  // @@protoc_insertion_point(class_scope:dullahan.models.TableSchema)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* table_name_;
  ::google::protobuf::RepeatedPtrField< ::dullahan::models::TableSchema_Column > columns_;
  friend void  protobuf_AddDesc_dullahan_2eproto();
  friend void protobuf_AssignDesc_dullahan_2eproto();
  friend void protobuf_ShutdownFile_dullahan_2eproto();

  void InitAsDefaultInstance();
  static TableSchema* default_instance_;
};
// -------------------------------------------------------------------

class TabletMetadata : public ::google::protobuf::Message {
 public:
  TabletMetadata();
  virtual ~TabletMetadata();

  TabletMetadata(const TabletMetadata& from);

  inline TabletMetadata& operator=(const TabletMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TabletMetadata& default_instance();

  void Swap(TabletMetadata* other);

  // implements Message ----------------------------------------------

  TabletMetadata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TabletMetadata& from);
  void MergeFrom(const TabletMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TabletMetadata_TabletVersion TabletVersion;
  static const TabletVersion ONE = TabletMetadata_TabletVersion_ONE;
  static inline bool TabletVersion_IsValid(int value) {
    return TabletMetadata_TabletVersion_IsValid(value);
  }
  static const TabletVersion TabletVersion_MIN =
    TabletMetadata_TabletVersion_TabletVersion_MIN;
  static const TabletVersion TabletVersion_MAX =
    TabletMetadata_TabletVersion_TabletVersion_MAX;
  static const int TabletVersion_ARRAYSIZE =
    TabletMetadata_TabletVersion_TabletVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TabletVersion_descriptor() {
    return TabletMetadata_TabletVersion_descriptor();
  }
  static inline const ::std::string& TabletVersion_Name(TabletVersion value) {
    return TabletMetadata_TabletVersion_Name(value);
  }
  static inline bool TabletVersion_Parse(const ::std::string& name,
      TabletVersion* value) {
    return TabletMetadata_TabletVersion_Parse(name, value);
  }

  typedef TabletMetadata_Endianness Endianness;
  static const Endianness BIG = TabletMetadata_Endianness_BIG;
  static const Endianness LITTLE = TabletMetadata_Endianness_LITTLE;
  static inline bool Endianness_IsValid(int value) {
    return TabletMetadata_Endianness_IsValid(value);
  }
  static const Endianness Endianness_MIN =
    TabletMetadata_Endianness_Endianness_MIN;
  static const Endianness Endianness_MAX =
    TabletMetadata_Endianness_Endianness_MAX;
  static const int Endianness_ARRAYSIZE =
    TabletMetadata_Endianness_Endianness_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Endianness_descriptor() {
    return TabletMetadata_Endianness_descriptor();
  }
  static inline const ::std::string& Endianness_Name(Endianness value) {
    return TabletMetadata_Endianness_Name(value);
  }
  static inline bool Endianness_Parse(const ::std::string& name,
      Endianness* value) {
    return TabletMetadata_Endianness_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .dullahan.models.TabletMetadata.TabletVersion tablet_version = 1;
  inline bool has_tablet_version() const;
  inline void clear_tablet_version();
  static const int kTabletVersionFieldNumber = 1;
  inline ::dullahan::models::TabletMetadata_TabletVersion tablet_version() const;
  inline void set_tablet_version(::dullahan::models::TabletMetadata_TabletVersion value);

  // optional uint32 highest_id = 2;
  inline bool has_highest_id() const;
  inline void clear_highest_id();
  static const int kHighestIdFieldNumber = 2;
  inline ::google::protobuf::uint32 highest_id() const;
  inline void set_highest_id(::google::protobuf::uint32 value);

  // optional uint64 timestamp_start = 3;
  inline bool has_timestamp_start() const;
  inline void clear_timestamp_start();
  static const int kTimestampStartFieldNumber = 3;
  inline ::google::protobuf::uint64 timestamp_start() const;
  inline void set_timestamp_start(::google::protobuf::uint64 value);

  // optional uint64 timestamp_stop = 4;
  inline bool has_timestamp_stop() const;
  inline void clear_timestamp_stop();
  static const int kTimestampStopFieldNumber = 4;
  inline ::google::protobuf::uint64 timestamp_stop() const;
  inline void set_timestamp_stop(::google::protobuf::uint64 value);

  // optional .dullahan.models.TabletMetadata.Endianness endianness = 5;
  inline bool has_endianness() const;
  inline void clear_endianness();
  static const int kEndiannessFieldNumber = 5;
  inline ::dullahan::models::TabletMetadata_Endianness endianness() const;
  inline void set_endianness(::dullahan::models::TabletMetadata_Endianness value);

  // optional uint32 size_of_bitword = 6;
  inline bool has_size_of_bitword() const;
  inline void clear_size_of_bitword();
  static const int kSizeOfBitwordFieldNumber = 6;
  inline ::google::protobuf::uint32 size_of_bitword() const;
  inline void set_size_of_bitword(::google::protobuf::uint32 value);

  // optional .dullahan.models.TableSchema table_metadata = 7;
  inline bool has_table_metadata() const;
  inline void clear_table_metadata();
  static const int kTableMetadataFieldNumber = 7;
  inline const ::dullahan::models::TableSchema& table_metadata() const;
  inline ::dullahan::models::TableSchema* mutable_table_metadata();
  inline ::dullahan::models::TableSchema* release_table_metadata();
  inline void set_allocated_table_metadata(::dullahan::models::TableSchema* table_metadata);

  // @@protoc_insertion_point(class_scope:dullahan.models.TabletMetadata)
 private:
  inline void set_has_tablet_version();
  inline void clear_has_tablet_version();
  inline void set_has_highest_id();
  inline void clear_has_highest_id();
  inline void set_has_timestamp_start();
  inline void clear_has_timestamp_start();
  inline void set_has_timestamp_stop();
  inline void clear_has_timestamp_stop();
  inline void set_has_endianness();
  inline void clear_has_endianness();
  inline void set_has_size_of_bitword();
  inline void clear_has_size_of_bitword();
  inline void set_has_table_metadata();
  inline void clear_has_table_metadata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int tablet_version_;
  ::google::protobuf::uint32 highest_id_;
  ::google::protobuf::uint64 timestamp_start_;
  ::google::protobuf::uint64 timestamp_stop_;
  int endianness_;
  ::google::protobuf::uint32 size_of_bitword_;
  ::dullahan::models::TableSchema* table_metadata_;
  friend void  protobuf_AddDesc_dullahan_2eproto();
  friend void protobuf_AssignDesc_dullahan_2eproto();
  friend void protobuf_ShutdownFile_dullahan_2eproto();

  void InitAsDefaultInstance();
  static TabletMetadata* default_instance_;
};
// -------------------------------------------------------------------

class Query_Predicate : public ::google::protobuf::Message {
 public:
  Query_Predicate();
  virtual ~Query_Predicate();

  Query_Predicate(const Query_Predicate& from);

  inline Query_Predicate& operator=(const Query_Predicate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Query_Predicate& default_instance();

  void Swap(Query_Predicate* other);

  // implements Message ----------------------------------------------

  Query_Predicate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Query_Predicate& from);
  void MergeFrom(const Query_Predicate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Query_Predicate_PredicateType PredicateType;
  static const PredicateType NODE = Query_Predicate_PredicateType_NODE;
  static const PredicateType AND = Query_Predicate_PredicateType_AND;
  static const PredicateType OR = Query_Predicate_PredicateType_OR;
  static inline bool PredicateType_IsValid(int value) {
    return Query_Predicate_PredicateType_IsValid(value);
  }
  static const PredicateType PredicateType_MIN =
    Query_Predicate_PredicateType_PredicateType_MIN;
  static const PredicateType PredicateType_MAX =
    Query_Predicate_PredicateType_PredicateType_MAX;
  static const int PredicateType_ARRAYSIZE =
    Query_Predicate_PredicateType_PredicateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PredicateType_descriptor() {
    return Query_Predicate_PredicateType_descriptor();
  }
  static inline const ::std::string& PredicateType_Name(PredicateType value) {
    return Query_Predicate_PredicateType_Name(value);
  }
  static inline bool PredicateType_Parse(const ::std::string& name,
      PredicateType* value) {
    return Query_Predicate_PredicateType_Parse(name, value);
  }

  typedef Query_Predicate_Operator Operator;
  static const Operator EQUAL = Query_Predicate_Operator_EQUAL;
  static const Operator NOT_EQUAL = Query_Predicate_Operator_NOT_EQUAL;
  static const Operator GREATER = Query_Predicate_Operator_GREATER;
  static const Operator GREATER_OR_EQUAL = Query_Predicate_Operator_GREATER_OR_EQUAL;
  static const Operator LESS = Query_Predicate_Operator_LESS;
  static const Operator LESS_OR_EQUAL = Query_Predicate_Operator_LESS_OR_EQUAL;
  static const Operator IN = Query_Predicate_Operator_IN;
  static const Operator NOT_IN = Query_Predicate_Operator_NOT_IN;
  static const Operator BETWEEN = Query_Predicate_Operator_BETWEEN;
  static const Operator NOT_BETWEEN = Query_Predicate_Operator_NOT_BETWEEN;
  static const Operator LIKE = Query_Predicate_Operator_LIKE;
  static const Operator NOT_LIKE = Query_Predicate_Operator_NOT_LIKE;
  static const Operator IS_NULL = Query_Predicate_Operator_IS_NULL;
  static const Operator IS_NOT_NULL = Query_Predicate_Operator_IS_NOT_NULL;
  static inline bool Operator_IsValid(int value) {
    return Query_Predicate_Operator_IsValid(value);
  }
  static const Operator Operator_MIN =
    Query_Predicate_Operator_Operator_MIN;
  static const Operator Operator_MAX =
    Query_Predicate_Operator_Operator_MAX;
  static const int Operator_ARRAYSIZE =
    Query_Predicate_Operator_Operator_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operator_descriptor() {
    return Query_Predicate_Operator_descriptor();
  }
  static inline const ::std::string& Operator_Name(Operator value) {
    return Query_Predicate_Operator_Name(value);
  }
  static inline bool Operator_Parse(const ::std::string& name,
      Operator* value) {
    return Query_Predicate_Operator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .dullahan.models.Query.Predicate.PredicateType type = 1 [default = NODE];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::dullahan::models::Query_Predicate_PredicateType type() const;
  inline void set_type(::dullahan::models::Query_Predicate_PredicateType value);

  // repeated .dullahan.models.Query.Predicate sub_predicates = 2;
  inline int sub_predicates_size() const;
  inline void clear_sub_predicates();
  static const int kSubPredicatesFieldNumber = 2;
  inline const ::dullahan::models::Query_Predicate& sub_predicates(int index) const;
  inline ::dullahan::models::Query_Predicate* mutable_sub_predicates(int index);
  inline ::dullahan::models::Query_Predicate* add_sub_predicates();
  inline const ::google::protobuf::RepeatedPtrField< ::dullahan::models::Query_Predicate >&
      sub_predicates() const;
  inline ::google::protobuf::RepeatedPtrField< ::dullahan::models::Query_Predicate >*
      mutable_sub_predicates();

  // optional uint32 column = 3;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 3;
  inline ::google::protobuf::uint32 column() const;
  inline void set_column(::google::protobuf::uint32 value);

  // optional .dullahan.models.Query.Predicate.Operator operator = 4;
  inline bool has_operator_() const;
  inline void clear_operator_();
  static const int kOperatorFieldNumber = 4;
  inline ::dullahan::models::Query_Predicate_Operator operator_() const;
  inline void set_operator_(::dullahan::models::Query_Predicate_Operator value);

  // repeated bytes operands = 5;
  inline int operands_size() const;
  inline void clear_operands();
  static const int kOperandsFieldNumber = 5;
  inline const ::std::string& operands(int index) const;
  inline ::std::string* mutable_operands(int index);
  inline void set_operands(int index, const ::std::string& value);
  inline void set_operands(int index, const char* value);
  inline void set_operands(int index, const void* value, size_t size);
  inline ::std::string* add_operands();
  inline void add_operands(const ::std::string& value);
  inline void add_operands(const char* value);
  inline void add_operands(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& operands() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_operands();

  // @@protoc_insertion_point(class_scope:dullahan.models.Query.Predicate)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_column();
  inline void clear_has_column();
  inline void set_has_operator_();
  inline void clear_has_operator_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::dullahan::models::Query_Predicate > sub_predicates_;
  int type_;
  ::google::protobuf::uint32 column_;
  ::google::protobuf::RepeatedPtrField< ::std::string> operands_;
  int operator__;
  friend void  protobuf_AddDesc_dullahan_2eproto();
  friend void protobuf_AssignDesc_dullahan_2eproto();
  friend void protobuf_ShutdownFile_dullahan_2eproto();

  void InitAsDefaultInstance();
  static Query_Predicate* default_instance_;
};
// -------------------------------------------------------------------

class Query : public ::google::protobuf::Message {
 public:
  Query();
  virtual ~Query();

  Query(const Query& from);

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Query& default_instance();

  void Swap(Query* other);

  // implements Message ----------------------------------------------

  Query* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Query_Predicate Predicate;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dullahan.models.Query)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_dullahan_2eproto();
  friend void protobuf_AssignDesc_dullahan_2eproto();
  friend void protobuf_ShutdownFile_dullahan_2eproto();

  void InitAsDefaultInstance();
  static Query* default_instance_;
};
// ===================================================================


// ===================================================================

// Record_KeyValue

// optional uint32 column = 1;
inline bool Record_KeyValue::has_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_KeyValue::set_has_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_KeyValue::clear_has_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_KeyValue::clear_column() {
  column_ = 0u;
  clear_has_column();
}
inline ::google::protobuf::uint32 Record_KeyValue::column() const {
  // @@protoc_insertion_point(field_get:dullahan.models.Record.KeyValue.column)
  return column_;
}
inline void Record_KeyValue::set_column(::google::protobuf::uint32 value) {
  set_has_column();
  column_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.Record.KeyValue.column)
}

// optional bytes value = 2;
inline bool Record_KeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Record_KeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Record_KeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Record_KeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Record_KeyValue::value() const {
  // @@protoc_insertion_point(field_get:dullahan.models.Record.KeyValue.value)
  return *value_;
}
inline void Record_KeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:dullahan.models.Record.KeyValue.value)
}
inline void Record_KeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:dullahan.models.Record.KeyValue.value)
}
inline void Record_KeyValue::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dullahan.models.Record.KeyValue.value)
}
inline ::std::string* Record_KeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dullahan.models.Record.KeyValue.value)
  return value_;
}
inline ::std::string* Record_KeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Record_KeyValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dullahan.models.Record.KeyValue.value)
}

// -------------------------------------------------------------------

// Record

// optional fixed64 timestamp = 1;
inline bool Record::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Record::timestamp() const {
  // @@protoc_insertion_point(field_get:dullahan.models.Record.timestamp)
  return timestamp_;
}
inline void Record::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.Record.timestamp)
}

// optional bytes id = 2;
inline bool Record::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Record::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Record::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Record::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Record::id() const {
  // @@protoc_insertion_point(field_get:dullahan.models.Record.id)
  return *id_;
}
inline void Record::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:dullahan.models.Record.id)
}
inline void Record::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:dullahan.models.Record.id)
}
inline void Record::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dullahan.models.Record.id)
}
inline ::std::string* Record::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dullahan.models.Record.id)
  return id_;
}
inline ::std::string* Record::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Record::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dullahan.models.Record.id)
}

// repeated .dullahan.models.Record.KeyValue values = 3;
inline int Record::values_size() const {
  return values_.size();
}
inline void Record::clear_values() {
  values_.Clear();
}
inline const ::dullahan::models::Record_KeyValue& Record::values(int index) const {
  // @@protoc_insertion_point(field_get:dullahan.models.Record.values)
  return values_.Get(index);
}
inline ::dullahan::models::Record_KeyValue* Record::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:dullahan.models.Record.values)
  return values_.Mutable(index);
}
inline ::dullahan::models::Record_KeyValue* Record::add_values() {
  // @@protoc_insertion_point(field_add:dullahan.models.Record.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dullahan::models::Record_KeyValue >&
Record::values() const {
  // @@protoc_insertion_point(field_list:dullahan.models.Record.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::dullahan::models::Record_KeyValue >*
Record::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:dullahan.models.Record.values)
  return &values_;
}

// -------------------------------------------------------------------

// TableSchema_Column

// optional .dullahan.models.TableSchema.Column.ColumnType type = 1;
inline bool TableSchema_Column::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableSchema_Column::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableSchema_Column::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableSchema_Column::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::dullahan::models::TableSchema_Column_ColumnType TableSchema_Column::type() const {
  // @@protoc_insertion_point(field_get:dullahan.models.TableSchema.Column.type)
  return static_cast< ::dullahan::models::TableSchema_Column_ColumnType >(type_);
}
inline void TableSchema_Column::set_type(::dullahan::models::TableSchema_Column_ColumnType value) {
  assert(::dullahan::models::TableSchema_Column_ColumnType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.TableSchema.Column.type)
}

// optional string name = 2;
inline bool TableSchema_Column::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableSchema_Column::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableSchema_Column::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableSchema_Column::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TableSchema_Column::name() const {
  // @@protoc_insertion_point(field_get:dullahan.models.TableSchema.Column.name)
  return *name_;
}
inline void TableSchema_Column::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:dullahan.models.TableSchema.Column.name)
}
inline void TableSchema_Column::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dullahan.models.TableSchema.Column.name)
}
inline void TableSchema_Column::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dullahan.models.TableSchema.Column.name)
}
inline ::std::string* TableSchema_Column::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dullahan.models.TableSchema.Column.name)
  return name_;
}
inline ::std::string* TableSchema_Column::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TableSchema_Column::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dullahan.models.TableSchema.Column.name)
}

// optional bool enabled = 3 [default = true];
inline bool TableSchema_Column::has_enabled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableSchema_Column::set_has_enabled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableSchema_Column::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableSchema_Column::clear_enabled() {
  enabled_ = true;
  clear_has_enabled();
}
inline bool TableSchema_Column::enabled() const {
  // @@protoc_insertion_point(field_get:dullahan.models.TableSchema.Column.enabled)
  return enabled_;
}
inline void TableSchema_Column::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.TableSchema.Column.enabled)
}

// optional .dullahan.models.TableSchema.Column.IndexType index_type = 4 [default = BITMAP];
inline bool TableSchema_Column::has_index_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableSchema_Column::set_has_index_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableSchema_Column::clear_has_index_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableSchema_Column::clear_index_type() {
  index_type_ = 1;
  clear_has_index_type();
}
inline ::dullahan::models::TableSchema_Column_IndexType TableSchema_Column::index_type() const {
  // @@protoc_insertion_point(field_get:dullahan.models.TableSchema.Column.index_type)
  return static_cast< ::dullahan::models::TableSchema_Column_IndexType >(index_type_);
}
inline void TableSchema_Column::set_index_type(::dullahan::models::TableSchema_Column_IndexType value) {
  assert(::dullahan::models::TableSchema_Column_IndexType_IsValid(value));
  set_has_index_type();
  index_type_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.TableSchema.Column.index_type)
}

// -------------------------------------------------------------------

// TableSchema

// optional string table_name = 1;
inline bool TableSchema::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableSchema::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableSchema::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableSchema::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& TableSchema::table_name() const {
  // @@protoc_insertion_point(field_get:dullahan.models.TableSchema.table_name)
  return *table_name_;
}
inline void TableSchema::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
  // @@protoc_insertion_point(field_set:dullahan.models.TableSchema.table_name)
}
inline void TableSchema::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dullahan.models.TableSchema.table_name)
}
inline void TableSchema::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dullahan.models.TableSchema.table_name)
}
inline ::std::string* TableSchema::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dullahan.models.TableSchema.table_name)
  return table_name_;
}
inline ::std::string* TableSchema::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TableSchema::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dullahan.models.TableSchema.table_name)
}

// repeated .dullahan.models.TableSchema.Column columns = 2;
inline int TableSchema::columns_size() const {
  return columns_.size();
}
inline void TableSchema::clear_columns() {
  columns_.Clear();
}
inline const ::dullahan::models::TableSchema_Column& TableSchema::columns(int index) const {
  // @@protoc_insertion_point(field_get:dullahan.models.TableSchema.columns)
  return columns_.Get(index);
}
inline ::dullahan::models::TableSchema_Column* TableSchema::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:dullahan.models.TableSchema.columns)
  return columns_.Mutable(index);
}
inline ::dullahan::models::TableSchema_Column* TableSchema::add_columns() {
  // @@protoc_insertion_point(field_add:dullahan.models.TableSchema.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dullahan::models::TableSchema_Column >&
TableSchema::columns() const {
  // @@protoc_insertion_point(field_list:dullahan.models.TableSchema.columns)
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::dullahan::models::TableSchema_Column >*
TableSchema::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:dullahan.models.TableSchema.columns)
  return &columns_;
}

// -------------------------------------------------------------------

// TabletMetadata

// optional .dullahan.models.TabletMetadata.TabletVersion tablet_version = 1;
inline bool TabletMetadata::has_tablet_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TabletMetadata::set_has_tablet_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TabletMetadata::clear_has_tablet_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TabletMetadata::clear_tablet_version() {
  tablet_version_ = 1;
  clear_has_tablet_version();
}
inline ::dullahan::models::TabletMetadata_TabletVersion TabletMetadata::tablet_version() const {
  // @@protoc_insertion_point(field_get:dullahan.models.TabletMetadata.tablet_version)
  return static_cast< ::dullahan::models::TabletMetadata_TabletVersion >(tablet_version_);
}
inline void TabletMetadata::set_tablet_version(::dullahan::models::TabletMetadata_TabletVersion value) {
  assert(::dullahan::models::TabletMetadata_TabletVersion_IsValid(value));
  set_has_tablet_version();
  tablet_version_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.TabletMetadata.tablet_version)
}

// optional uint32 highest_id = 2;
inline bool TabletMetadata::has_highest_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TabletMetadata::set_has_highest_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TabletMetadata::clear_has_highest_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TabletMetadata::clear_highest_id() {
  highest_id_ = 0u;
  clear_has_highest_id();
}
inline ::google::protobuf::uint32 TabletMetadata::highest_id() const {
  // @@protoc_insertion_point(field_get:dullahan.models.TabletMetadata.highest_id)
  return highest_id_;
}
inline void TabletMetadata::set_highest_id(::google::protobuf::uint32 value) {
  set_has_highest_id();
  highest_id_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.TabletMetadata.highest_id)
}

// optional uint64 timestamp_start = 3;
inline bool TabletMetadata::has_timestamp_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TabletMetadata::set_has_timestamp_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TabletMetadata::clear_has_timestamp_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TabletMetadata::clear_timestamp_start() {
  timestamp_start_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_start();
}
inline ::google::protobuf::uint64 TabletMetadata::timestamp_start() const {
  // @@protoc_insertion_point(field_get:dullahan.models.TabletMetadata.timestamp_start)
  return timestamp_start_;
}
inline void TabletMetadata::set_timestamp_start(::google::protobuf::uint64 value) {
  set_has_timestamp_start();
  timestamp_start_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.TabletMetadata.timestamp_start)
}

// optional uint64 timestamp_stop = 4;
inline bool TabletMetadata::has_timestamp_stop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TabletMetadata::set_has_timestamp_stop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TabletMetadata::clear_has_timestamp_stop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TabletMetadata::clear_timestamp_stop() {
  timestamp_stop_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_stop();
}
inline ::google::protobuf::uint64 TabletMetadata::timestamp_stop() const {
  // @@protoc_insertion_point(field_get:dullahan.models.TabletMetadata.timestamp_stop)
  return timestamp_stop_;
}
inline void TabletMetadata::set_timestamp_stop(::google::protobuf::uint64 value) {
  set_has_timestamp_stop();
  timestamp_stop_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.TabletMetadata.timestamp_stop)
}

// optional .dullahan.models.TabletMetadata.Endianness endianness = 5;
inline bool TabletMetadata::has_endianness() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TabletMetadata::set_has_endianness() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TabletMetadata::clear_has_endianness() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TabletMetadata::clear_endianness() {
  endianness_ = 0;
  clear_has_endianness();
}
inline ::dullahan::models::TabletMetadata_Endianness TabletMetadata::endianness() const {
  // @@protoc_insertion_point(field_get:dullahan.models.TabletMetadata.endianness)
  return static_cast< ::dullahan::models::TabletMetadata_Endianness >(endianness_);
}
inline void TabletMetadata::set_endianness(::dullahan::models::TabletMetadata_Endianness value) {
  assert(::dullahan::models::TabletMetadata_Endianness_IsValid(value));
  set_has_endianness();
  endianness_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.TabletMetadata.endianness)
}

// optional uint32 size_of_bitword = 6;
inline bool TabletMetadata::has_size_of_bitword() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TabletMetadata::set_has_size_of_bitword() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TabletMetadata::clear_has_size_of_bitword() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TabletMetadata::clear_size_of_bitword() {
  size_of_bitword_ = 0u;
  clear_has_size_of_bitword();
}
inline ::google::protobuf::uint32 TabletMetadata::size_of_bitword() const {
  // @@protoc_insertion_point(field_get:dullahan.models.TabletMetadata.size_of_bitword)
  return size_of_bitword_;
}
inline void TabletMetadata::set_size_of_bitword(::google::protobuf::uint32 value) {
  set_has_size_of_bitword();
  size_of_bitword_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.TabletMetadata.size_of_bitword)
}

// optional .dullahan.models.TableSchema table_metadata = 7;
inline bool TabletMetadata::has_table_metadata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TabletMetadata::set_has_table_metadata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TabletMetadata::clear_has_table_metadata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TabletMetadata::clear_table_metadata() {
  if (table_metadata_ != NULL) table_metadata_->::dullahan::models::TableSchema::Clear();
  clear_has_table_metadata();
}
inline const ::dullahan::models::TableSchema& TabletMetadata::table_metadata() const {
  // @@protoc_insertion_point(field_get:dullahan.models.TabletMetadata.table_metadata)
  return table_metadata_ != NULL ? *table_metadata_ : *default_instance_->table_metadata_;
}
inline ::dullahan::models::TableSchema* TabletMetadata::mutable_table_metadata() {
  set_has_table_metadata();
  if (table_metadata_ == NULL) table_metadata_ = new ::dullahan::models::TableSchema;
  // @@protoc_insertion_point(field_mutable:dullahan.models.TabletMetadata.table_metadata)
  return table_metadata_;
}
inline ::dullahan::models::TableSchema* TabletMetadata::release_table_metadata() {
  clear_has_table_metadata();
  ::dullahan::models::TableSchema* temp = table_metadata_;
  table_metadata_ = NULL;
  return temp;
}
inline void TabletMetadata::set_allocated_table_metadata(::dullahan::models::TableSchema* table_metadata) {
  delete table_metadata_;
  table_metadata_ = table_metadata;
  if (table_metadata) {
    set_has_table_metadata();
  } else {
    clear_has_table_metadata();
  }
  // @@protoc_insertion_point(field_set_allocated:dullahan.models.TabletMetadata.table_metadata)
}

// -------------------------------------------------------------------

// Query_Predicate

// optional .dullahan.models.Query.Predicate.PredicateType type = 1 [default = NODE];
inline bool Query_Predicate::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Query_Predicate::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Query_Predicate::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Query_Predicate::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::dullahan::models::Query_Predicate_PredicateType Query_Predicate::type() const {
  // @@protoc_insertion_point(field_get:dullahan.models.Query.Predicate.type)
  return static_cast< ::dullahan::models::Query_Predicate_PredicateType >(type_);
}
inline void Query_Predicate::set_type(::dullahan::models::Query_Predicate_PredicateType value) {
  assert(::dullahan::models::Query_Predicate_PredicateType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.Query.Predicate.type)
}

// repeated .dullahan.models.Query.Predicate sub_predicates = 2;
inline int Query_Predicate::sub_predicates_size() const {
  return sub_predicates_.size();
}
inline void Query_Predicate::clear_sub_predicates() {
  sub_predicates_.Clear();
}
inline const ::dullahan::models::Query_Predicate& Query_Predicate::sub_predicates(int index) const {
  // @@protoc_insertion_point(field_get:dullahan.models.Query.Predicate.sub_predicates)
  return sub_predicates_.Get(index);
}
inline ::dullahan::models::Query_Predicate* Query_Predicate::mutable_sub_predicates(int index) {
  // @@protoc_insertion_point(field_mutable:dullahan.models.Query.Predicate.sub_predicates)
  return sub_predicates_.Mutable(index);
}
inline ::dullahan::models::Query_Predicate* Query_Predicate::add_sub_predicates() {
  // @@protoc_insertion_point(field_add:dullahan.models.Query.Predicate.sub_predicates)
  return sub_predicates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dullahan::models::Query_Predicate >&
Query_Predicate::sub_predicates() const {
  // @@protoc_insertion_point(field_list:dullahan.models.Query.Predicate.sub_predicates)
  return sub_predicates_;
}
inline ::google::protobuf::RepeatedPtrField< ::dullahan::models::Query_Predicate >*
Query_Predicate::mutable_sub_predicates() {
  // @@protoc_insertion_point(field_mutable_list:dullahan.models.Query.Predicate.sub_predicates)
  return &sub_predicates_;
}

// optional uint32 column = 3;
inline bool Query_Predicate::has_column() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Query_Predicate::set_has_column() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Query_Predicate::clear_has_column() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Query_Predicate::clear_column() {
  column_ = 0u;
  clear_has_column();
}
inline ::google::protobuf::uint32 Query_Predicate::column() const {
  // @@protoc_insertion_point(field_get:dullahan.models.Query.Predicate.column)
  return column_;
}
inline void Query_Predicate::set_column(::google::protobuf::uint32 value) {
  set_has_column();
  column_ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.Query.Predicate.column)
}

// optional .dullahan.models.Query.Predicate.Operator operator = 4;
inline bool Query_Predicate::has_operator_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Query_Predicate::set_has_operator_() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Query_Predicate::clear_has_operator_() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Query_Predicate::clear_operator_() {
  operator__ = 1;
  clear_has_operator_();
}
inline ::dullahan::models::Query_Predicate_Operator Query_Predicate::operator_() const {
  // @@protoc_insertion_point(field_get:dullahan.models.Query.Predicate.operator)
  return static_cast< ::dullahan::models::Query_Predicate_Operator >(operator__);
}
inline void Query_Predicate::set_operator_(::dullahan::models::Query_Predicate_Operator value) {
  assert(::dullahan::models::Query_Predicate_Operator_IsValid(value));
  set_has_operator_();
  operator__ = value;
  // @@protoc_insertion_point(field_set:dullahan.models.Query.Predicate.operator)
}

// repeated bytes operands = 5;
inline int Query_Predicate::operands_size() const {
  return operands_.size();
}
inline void Query_Predicate::clear_operands() {
  operands_.Clear();
}
inline const ::std::string& Query_Predicate::operands(int index) const {
  // @@protoc_insertion_point(field_get:dullahan.models.Query.Predicate.operands)
  return operands_.Get(index);
}
inline ::std::string* Query_Predicate::mutable_operands(int index) {
  // @@protoc_insertion_point(field_mutable:dullahan.models.Query.Predicate.operands)
  return operands_.Mutable(index);
}
inline void Query_Predicate::set_operands(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:dullahan.models.Query.Predicate.operands)
  operands_.Mutable(index)->assign(value);
}
inline void Query_Predicate::set_operands(int index, const char* value) {
  operands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dullahan.models.Query.Predicate.operands)
}
inline void Query_Predicate::set_operands(int index, const void* value, size_t size) {
  operands_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dullahan.models.Query.Predicate.operands)
}
inline ::std::string* Query_Predicate::add_operands() {
  return operands_.Add();
}
inline void Query_Predicate::add_operands(const ::std::string& value) {
  operands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dullahan.models.Query.Predicate.operands)
}
inline void Query_Predicate::add_operands(const char* value) {
  operands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dullahan.models.Query.Predicate.operands)
}
inline void Query_Predicate::add_operands(const void* value, size_t size) {
  operands_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dullahan.models.Query.Predicate.operands)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Query_Predicate::operands() const {
  // @@protoc_insertion_point(field_list:dullahan.models.Query.Predicate.operands)
  return operands_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Query_Predicate::mutable_operands() {
  // @@protoc_insertion_point(field_mutable_list:dullahan.models.Query.Predicate.operands)
  return &operands_;
}

// -------------------------------------------------------------------

// Query


// @@protoc_insertion_point(namespace_scope)

}  // namespace models
}  // namespace dullahan

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::dullahan::models::TableSchema_Column_ColumnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dullahan::models::TableSchema_Column_ColumnType>() {
  return ::dullahan::models::TableSchema_Column_ColumnType_descriptor();
}
template <> struct is_proto_enum< ::dullahan::models::TableSchema_Column_IndexType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dullahan::models::TableSchema_Column_IndexType>() {
  return ::dullahan::models::TableSchema_Column_IndexType_descriptor();
}
template <> struct is_proto_enum< ::dullahan::models::TabletMetadata_TabletVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dullahan::models::TabletMetadata_TabletVersion>() {
  return ::dullahan::models::TabletMetadata_TabletVersion_descriptor();
}
template <> struct is_proto_enum< ::dullahan::models::TabletMetadata_Endianness> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dullahan::models::TabletMetadata_Endianness>() {
  return ::dullahan::models::TabletMetadata_Endianness_descriptor();
}
template <> struct is_proto_enum< ::dullahan::models::Query_Predicate_PredicateType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dullahan::models::Query_Predicate_PredicateType>() {
  return ::dullahan::models::Query_Predicate_PredicateType_descriptor();
}
template <> struct is_proto_enum< ::dullahan::models::Query_Predicate_Operator> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dullahan::models::Query_Predicate_Operator>() {
  return ::dullahan::models::Query_Predicate_Operator_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dullahan_2eproto__INCLUDED
